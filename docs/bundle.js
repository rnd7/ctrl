/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../ctrl/index.js":
/*!************************!*\
  !*** ../ctrl/index.js ***!
  \************************/
/*! exports provided: Rotary */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rotary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rotary */ \"../ctrl/rotary.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Rotary\", function() { return _rotary__WEBPACK_IMPORTED_MODULE_0__[\"Rotary\"]; });\n\n\n//console.log(components)\n\n\n\n//# sourceURL=webpack:///../ctrl/index.js?");

/***/ }),

/***/ "../ctrl/rotary.js":
/*!*************************!*\
  !*** ../ctrl/rotary.js ***!
  \*************************/
/*! exports provided: NONE, VALUE, TARGET, STEP, COMPLETE, ALWAYS, ROTARY_DEFAULTS, Rotary */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NONE\", function() { return NONE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VALUE\", function() { return VALUE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TARGET\", function() { return TARGET; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"STEP\", function() { return STEP; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMPLETE\", function() { return COMPLETE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ALWAYS\", function() { return ALWAYS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ROTARY_DEFAULTS\", function() { return ROTARY_DEFAULTS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rotary\", function() { return Rotary; });\n\nconst TAU = Math.PI * 2\nconst HALF_PI = Math.PI / 2\n\nfunction mod( a, n ) { return ( a % n + n ) % n }\n\nfunction calcAngle(ax, ay, bx, by) {\n  var angle = Math.atan2(by - ay, bx - ax)\n  if ( angle < 0 ) angle += TAU\n  return angle\n}\n\nfunction calcAngleDelta( current, target ) {\n  var a = mod( ( current - target ), TAU )\n  var b = mod( ( target - current ), TAU)\n  return a < b ? -a : b\n}\n\nfunction clamp(val, min, max) {\n  return Math.min(max || 1, Math.max(min || 0, val))\n}\n\nfunction drawTorusSegment(ctx, x, y, outer, inner, start, end) {\n  start = start || 0\n  end = end || TAU\n  ctx.beginPath()\n  ctx.arc(x, y, outer, start , end, false)\n  ctx.arc(x, y, inner, end, start, true)\n  ctx.closePath()\n}\n\n// Event Modes\nconst NONE = \"none\" // no events fired\nconst VALUE = \"value\" // only on value changes\nconst TARGET = \"target\" // only on target changes\nconst STEP = \"step\" // only on step changes\nconst COMPLETE = \"complete\" // only when value reaches target\nconst ALWAYS = \"always\" // while user interacts\n\n\nconst ROTARY_DEFAULTS = {\n  observeSize: false, // poll for parent size changes\n  sizeFromParent: true, // fit within parent bounds\n  eventMode: VALUE, // online fire events when value changed\n  speed: .01, // value per frame 0 and 1 eq instant change\n  value: 0., // 0-1\n  initialChangeEvent: true, // trigger change event when listener added\n  keepTarget: false, // value setter does not overwrite target\n  disabled: false, // non interactive\n  neutralAngle: -HALF_PI, // track orientation\n  borderRadius: 2,\n  borderColor: 'rgb(12,12,12)',\n  borderFocusColor: 'rgb(0,0,80)',\n  backgroundColor: 'rgb(36,36,36)',\n  steps: 1, // 1-n to specify steps 1 is continous\n  stepGap: TAU / 360, // stepper only. gap between segments\n  trackSize: 12, // width of the track\n  trackSector: TAU * .8, // track span as circular sector\n  trackSectorColor: 'rgb(66,66,66)',\n  valueSector: TAU / 48, // size of value indicator\n  valueSectorColor: 'rgb(255,255,255)',\n  targetSector: TAU / 48, // size of target indicator\n  targetSectorColor: 'rgba(170,170,255,.5)',\n}\n\nclass Rotary {\n  constructor(opts) {\n    this._canvas = document.createElement('CANVAS')\n    this._canvas.tabIndex = 0\n    this._canvas.style.outline = 0\n    this._canvas.style.userSelect = \"none\"\n    this._canvas.style.cursor = \"pointer\"\n    this._ctx = this._canvas.getContext(\"2d\")\n    this._target = null\n    this._mouseX = 0.\n    this._mouseY = 0.\n    this._mouseAngle = 0.\n    this._bound = {\n      startDrag: this.startDrag.bind(this),\n      stopDrag: this.stopDrag.bind(this),\n      drag: this.drag.bind(this),\n      focus: this.focus.bind(this),\n      blur: this.blur.bind(this)\n    }\n\n    this.assign(ROTARY_DEFAULTS, opts)\n    if (this.target === null) this.target = this.value // if no target use value\n\n    this._canvas.addEventListener(\"mousedown\", this._bound.startDrag)\n    this._canvas.addEventListener(\"focus\", this._bound.focus, true)\n    this._canvas.addEventListener(\"blur\", this._bound.blur, true)\n  }\n\n  startDrag(e) {\n    if (this._disabled) return\n    this._dragging = true\n    this._canvas.removeEventListener(\"mousedown\", this._bound.startDrag)\n    this._canvas.removeEventListener(\"touchstart\", this._bound.startDrag)\n    document.addEventListener(\"mousemove\", this._bound.drag)\n    document.addEventListener(\"touchmove\", this._bound.drag)\n    document.addEventListener(\"mouseup\", this._bound.stopDrag)\n    document.addEventListener(\"mouseleave\", this._bound.stopDrag)\n    document.addEventListener(\"dragleave\", this._bound.stopDrag)\n    document.addEventListener(\"touchcancel\", this._bound.stopDrag)\n    document.addEventListener(\"touchend\", this._bound.stopDrag)\n    this._evalMousePosition(e)\n  }\n\n  drag(e) {\n    if (this._disabled) return\n    this._evalMousePosition(e)\n  }\n\n  stopDrag(e) {\n    if (this._disabled) return\n    this._dragging = false\n    document.removeEventListener(\"mousemove\", this._bound.drag)\n    document.removeEventListener(\"touchmove\", this._bound.drag)\n    document.removeEventListener(\"mouseup\", this._bound.stopDrag)\n    document.removeEventListener(\"mouseleave\", this._bound.stopDrag)\n    document.removeEventListener(\"dragleave\", this._bound.stopDrag)\n    document.removeEventListener(\"touchcancel\", this._bound.stopDrag)\n    document.removeEventListener(\"touchend\", this._bound.stopDrag)\n    this._canvas.addEventListener(\"mousedown\", this._bound.startDrag)\n    this._canvas.addEventListener(\"touchstart\", this._bound.startDrag)\n    this._evalMousePosition(e)\n  }\n\n  focus(e) {\n    if (this._disabled) return\n    this._focus = true\n    this.redraw()\n  }\n\n  blur(e) {\n    if (this._disabled) return\n    this._focus = false\n    this.redraw()\n  }\n\n  on(...args) {\n    this.addEventListener.apply(this, args)\n  }\n\n  addEventListener(...args) {\n    this._canvas.addEventListener.apply(this._canvas, args)\n    if (this._initialChangeEvent) this._dispatchChangeEvent(true)\n  }\n\n  off(...args) {\n    this.removeEventListener.apply(this, args)\n  }\n\n  removeEventListener(...args) {\n    this._canvas.removeEventListener.apply(this._canvas, args)\n  }\n\n  assign (...args) {\n    this._bulkAssign = true\n    args.forEach((arg) => {\n      Object.assign(this, arg)\n    })\n    this._bulkAssign = false\n    if (this._redraw) this._loop()\n  }\n\n  set initialChangeEvent(val) {\n    if (this._initialChangeEvent == val) return\n    this._initialChangeEvent = val\n  }\n  get initialChangeEvent() {\n    return this._initialChangeEvent\n  }\n\n  set eventMode(val) {\n    this._eventMode = val\n  }\n  get eventMode() {\n    return this._eventMode\n  }\n\n  set selector(val) {\n    this._selector = val\n    this.parent = document.querySelector(this._selector)\n  }\n  get selector() {\n    return this._selector\n  }\n\n  set parent(val) {\n    this._parent = val\n    this._attachDomElement()\n  }\n  get parent() {\n    return this._parent\n  }\n\n  set value(val) {\n    if (this._value == val) return\n    this._value = clamp(val)\n    if (!this._bulkAssign) this.target = this._value\n    this.redraw()\n  }\n  get value() {\n    return this._value\n  }\n\n  set trackSector(val) {\n    if (this._trackSector == val) return\n    this._trackSector = val\n    this.redraw()\n  }\n  get trackSector() {\n    return this._trackSector\n  }\n\n  set target(val) {\n    if (this._target == val) return\n    this._target = clamp(val)\n    this.redraw()\n  }\n  get target() {\n    return this._target\n  }\n\n  set keepTarget(val) {\n    if (this._keepTarget == val) return\n    this._keepTarget = val\n  }\n  get keepTarget() {\n    return this._keepTarget\n  }\n\n\n  set steps(val) {\n    if (this._steps == val) return\n    this._steps = Math.max(1,val)\n    this.redraw()\n  }\n  get steps() {\n    return this._steps\n  }\n\n  get step() {\n    return Math.round(this._value * (this._steps-1))\n  }\n\n  set step(val) {\n    this.value = val / this._steps\n  }\n\n  get targetStep() {\n    return Math.round(this._target * (this._steps-1))\n  }\n\n  set targetStep(val) {\n    this.target = val / this._steps\n  }\n\n  set neutralAngle(val) {\n    if (this._neutralAngle == val) return\n    this._neutralAngle = val\n    this.redraw()\n  }\n  get neutralAngle() {\n    return this._neutralAngle\n  }\n\n  set sizeFromParent(val) {\n    if (this._sizeFromParent == val) return\n    this._sizeFromParent = val\n    if (this._sizeFromParent) this.fitParent()\n  }\n  get sizeFromParent() {\n    return this._sizeFromParent\n  }\n\n  set width(val) {\n    if (this._width == val) return\n    this._width = val\n    this._resizeCanvas()\n  }\n  get width() {\n    return this._width\n  }\n\n  set height(val) {\n    if (this._height == val) return\n    this._height = val\n    this._resizeCanvas()\n  }\n  get height() {\n    return this._height\n  }\n\n  set speed(val) {\n    if (this._speed == val) return\n    this._speed = val\n  }\n  get speed() {\n    return this._speed\n  }\n\n  set targetSector(val) {\n    if (this._targetSector == val) return\n    this._targetSector = val\n    this.redraw()\n  }\n  get targetSector() {\n    return this._targetSector\n  }\n\n  set valueSector(val) {\n    if (this._valueSector == val) return\n    this._valueSector = val\n    this.redraw()\n  }\n  get valueSector() {\n    return this._valueSector\n  }\n\n  set stepGap(val) {\n    if (this._stepGap == val) return\n    this._stepGap = val\n    this.redraw()\n  }\n  get stepGap() {\n    return this._stepGap\n  }\n\n  set disabled(val) {\n    if (this._disabled == val) return\n    this._disabled = val\n    if (this._disabled && this._dragging) this.stopDrag()\n    if (this._disabled && this._focus) this.blur()\n    this.redraw()\n  }\n  get disabled() {\n    return this._disabled\n  }\n\n  set observeSize(val) {\n    if (this._observeSize == val) return\n    this._observeSize = val\n    if (this._observeSize) this._loop()\n  }\n  get observeSize() {\n    return observeSize\n  }\n\n  set borderRadius(val) {\n    if (this._borderRadius == val) return\n    this._borderRadius = val\n    this.redraw()\n  }\n  get borderRadius() {\n    return this._borderRadius\n  }\n\n  set trackSize(val) {\n    if (this._trackSize == val) return\n    this._trackSize = val\n    this.redraw()\n  }\n  get trackSize() {\n    return this._trackSize\n  }\n\n  set valueSectorColor(val) {\n    if (this._valueSectorColor == val) return\n    this._valueSectorColor = val\n    this.redraw()\n  }\n  get valueSectorColor() {\n    return this._valueSectorColor\n  }\n\n  set trackSectorColor(val) {\n    if (this._trackSectorColor == val) return\n    this._trackSectorColor = val\n    this.redraw()\n  }\n  get trackSectorColor() {\n    return this._trackSectorColor\n  }\n\n  set borderColor(val) {\n    if (this._borderColor == val) return\n    this._borderColor = val\n    this.redraw()\n  }\n  get borderColor() {\n    return this._borderColor\n  }\n\n  set borderFocusColor(val) {\n    if (this._borderFocusColor == val) return\n    this._borderFocusColor = val\n    this.redraw()\n  }\n  get borderFocusColor() {\n    return this._borderFocusColor\n  }\n\n  set backgroundColor(val) {\n    if (this._backgroundColor == val) return\n    this._backgroundColor = val\n    this.redraw()\n  }\n  get backgroundColor() {\n    return this._backgroundColor\n  }\n\n  set targetSectorColor(val) {\n    if (this._targetSectorColor == val) return\n    this._targetSectorColor = val\n    this.redraw()\n  }\n  get targetSectorColor() {\n    return this._targetSectorColor\n  }\n\n  get domElement() {\n    return this._canvas\n  }\n\n  fitParent() {\n    if (!this._parent) return\n    this._width = this._parent.offsetWidth\n    this._height =  this._parent.offsetHeight\n    this._resizeCanvas()\n  }\n\n  redraw() {\n    this._redraw = true\n    if (!this._bulkAssign) this._loop()\n  }\n\n  _resizeCanvas() {\n    this._canvasSize = Math.min(this._width, this._height)\n    this._radius =  this._canvasSize / 2.\n    this._centerX = this._centerY = this._radius\n    this.redraw()\n  }\n\n  _attachDomElement() {\n    if (this.parent && this._canvas) {\n      this._parent.appendChild(this._canvas)\n      this.fitParent()\n      this.redraw()\n    }\n  }\n\n  _evalMousePosition(e){\n    this._mouseX = e.touches ? e.touches[0].pageX : e.pageX\n    this._mouseY = e.touches ? e.touches[0].pageY : e.pageY\n    this._mouseAngle = calcAngle(\n      this._canvas.offsetLeft + this._canvasSize / 2,\n      this._canvas.offsetTop + this._canvasSize / 2,\n      this._mouseX,\n      this._mouseY\n    )\n    const zero = (this._neutralAngle - Math.PI)\n    const inverse = (TAU - (this._trackSector - this._valueSector)) / TAU\n    const fullCircle = mod(this._mouseAngle - zero, TAU) / TAU\n    const value = fullCircle\n      * (TAU / (this._trackSector - this._valueSector))\n      - (inverse + this._valueSector / 2) / 2\n\n    this._target = clamp(value)\n    this.redraw()\n  }\n\n  _dispatchChangeEvent(force) {\n    if (\n      !force\n      && (\n        this._eventMode === NONE\n        || (this._eventMode === VALUE && this._lastEventValue == this._value)\n        || (this._eventMode === TARGET && this._lastEventTarget == this._target)\n        || (this._eventMode === STEP && this._lastEventStep == this.step)\n        || (this._eventMode === COMPLETE && this._value != this._target)\n      )\n    ) return\n    this._canvas.dispatchEvent(\n      new CustomEvent(\n        'change',\n        {\n          bubbles: true,\n          detail: {\n            step: this.step,\n            value: this._value,\n            target: this._target,\n            component: this\n          }\n        }\n      )\n    )\n    this._lastEventValue = this._value\n    this._lastEventTarget = this._target\n    this._lastEventStep = this.step\n  }\n\n  _loop() {\n    if (\n      this._animationFrame\n      || (\n        !this._observeSize\n        && !this._dragging\n        && !this._redraw\n        && this._value == this._target\n      )\n    ) return\n    this._animationFrame = window.requestAnimationFrame(() => {\n      let render = this._dragging || this._redraw\n      if (this._value != this._target) {\n        if (this.speed && this._value + this._speed <= this._target ) {\n          this._value += this._speed\n        } else if (this.speed && this._value- this._speed >= this._target ) {\n          this._value -= this._speed\n        } else {\n          this._value = this._target\n        }\n        render = true\n        this._dispatchChangeEvent()\n      }\n      if (\n        this._observeSize\n        && this._sizeFromParent\n        && (\n          this._parent.offsetWidth != this._width\n          || this._parent.offsetHeight != this._height\n        )\n      ) {\n        this.fitParent()\n        render = true\n      }\n      this._animationFrame = null\n      if (render) this._draw()\n      this._loop()\n    })\n  }\n\n  _draw() {\n    const ctx = this._ctx\n    const cx = this._centerX\n    const cy = this._centerY\n    const border = this._borderRadius\n    const trackSize = Math.min(this._radius/3, this._trackSize)\n    const zero = -this._trackSector/2 + this._neutralAngle\n    const limit = zero + this._trackSector\n    const delta = calcAngleDelta( zero,limit)\n    const target = this._target\n    const value = this._value\n\n    const outer = this._radius - border\n    const inner = this._radius - border - trackSize\n\n    if (\n      ctx.canvas.width != this._canvasSize\n      || ctx.canvas.height != this._canvasSize\n    ) {\n      ctx.canvas.width = ctx.canvas.height = this._canvasSize\n    } else {\n      ctx.clearRect(0, 0, this._canvasSize, this._canvasSize)\n    }\n\n\n\n    // background torus\n    ctx.save()\n    ctx.beginPath()\n    ctx.fillStyle = this._focus ? this._borderFocusColor : this._borderColor\n    ctx.arc(cx, cy, this._radius, 0, TAU)\n    ctx.arc(cx, cy, inner - border, 0, TAU, true)\n    ctx.clip()\n    ctx.fill()\n    ctx.restore()\n\n    // torus\n    ctx.fillStyle = this._backgroundColor\n    drawTorusSegment(ctx, cx, cy, outer, inner)\n    ctx.fill()\n\n    let start, end\n    if (this._steps < 2) {\n\n      // track\n      ctx.fillStyle = this._trackSectorColor\n      drawTorusSegment(ctx, cx, cy, outer, inner, zero, limit)\n      ctx.fill()\n\n      // target value indicator\n      if (value != target) {\n        start = target *((TAU + delta - this._targetSector)) + zero\n        end = start + this._targetSector\n        ctx.fillStyle = this._targetSectorColor\n        drawTorusSegment(ctx, cx, cy, outer, inner, start, end)\n        ctx.fill()\n      }\n\n      // current value indicator\n      start = value * (TAU + delta - this._valueSector) + zero\n      end = start + this._valueSector\n      ctx.fillStyle = this._valueSectorColor\n      drawTorusSegment(ctx, cx, cy, outer, inner, start, end)\n      ctx.fill()\n\n    } else {\n\n      const segmentSector = this._trackSector / this._steps\n      const stepScale = 1 / this._steps\n      const step = this.step\n      const targetStep = this.targetStep\n      // draw segment for every step\n      for (let i = 0; i < this._steps; i++) {\n        start = mod(zero + segmentSector * i, TAU) + this._stepGap\n        end = mod(zero + segmentSector * (i + 1), TAU) - this._stepGap\n        // segmented track\n        ctx.fillStyle = this._trackSectorColor\n        drawTorusSegment(ctx, cx, cy, outer, inner, start, end)\n        ctx.fill()\n        if (step == i) {\n          // segment matches current value\n          ctx.fillStyle = this._valueSectorColor\n          drawTorusSegment(ctx, cx, cy, outer, inner, start, end)\n          ctx.fill()\n        } else if (value != target && targetStep == i) {\n          //if (target >= i * stepScale && target <= (i + 1) * stepScale) {\n            // current value neq target value segement matches selected step\n            ctx.fillStyle = this._targetSectorColor\n            drawTorusSegment(ctx, cx, cy, outer, inner, start, end)\n            ctx.fill()\n        //  }\n        }\n      }\n    }\n    this._redraw = false\n  }\n}\n\n\n//# sourceURL=webpack:///../ctrl/rotary.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ctrl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ctrl */ \"../ctrl/index.js\");\n  // aka '@rnd7/ctrl'\n\nwindow.addEventListener(\"load\", e => {\n\n  // most basic example, using defaults\n  (() => {\n    const rotary = new _ctrl__WEBPACK_IMPORTED_MODULE_0__[\"Rotary\"]()\n    rotary.speed = 0 // instant change\n    // set the parent of the rotary to append it to the DOM\n    rotary.parent = document.getElementById('rotary-1')\n  })();\n\n\n  // more sophisticated example\n  (() => {\n    const display = document.getElementById('rotary-2-display')\n    new _ctrl__WEBPACK_IMPORTED_MODULE_0__[\"Rotary\"]({\n      selector:'#rotary-2',\n      value:.5,\n    }).on(\"change\", e => {\n      display.innerHTML = ((Math.round(e.detail.value * 100))/100).toFixed(2);\n     })\n  })();\n\n  // Stepper with display\n  (() => {\n    const display = document.getElementById('rotary-3-display')\n    const rotary = new _ctrl__WEBPACK_IMPORTED_MODULE_0__[\"Rotary\"]({\n      parent: document.getElementById('rotary-3'),\n      step:12,\n      targetStep: 0,\n      steps:12,\n      eventMode:\"step\"\n    })\n    rotary.on(\"change\", e => { display.innerHTML = e.detail.step })\n  })();\n\n  // Styling Example\n  (() => {\n    const rotary = new _ctrl__WEBPACK_IMPORTED_MODULE_0__[\"Rotary\"]({\n      selector: '#rotary-4',\n      borderRadius: 0,\n      borderColor: 'rgba(255,255,255,.25)',\n      borderFocusColor: 'rgba(255,255,255,.5)',\n      backgroundColor: 'rgba(255,255,255,0)',\n      trackSectorColor: 'rgba(0,0,0,.3)',\n      valueSectorColor: 'rgba(255,255,255,.6)',\n      targetSectorColor: 'rgba(0,0,0,.3)',\n      trackSize: 24,\n      steps:12,\n      stepGap: 0,\n      eventMode:\"step\"\n    })\n    rotary.assign(\n      { target: 1. },\n      { speed: .001 }\n    )\n  })();\n\n  // Responsive Example\n  (() => {\n    const button = document.getElementById('rotary-5-button')\n    const parent = document.getElementById('rotary-5')\n    const rotary = new _ctrl__WEBPACK_IMPORTED_MODULE_0__[\"Rotary\"]({\n      parent,\n      observeSize: true\n    })\n    button.addEventListener('click', (e) => {\n      parent.classList.toggle('big')\n    })\n  })();\n})\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ })

/******/ });